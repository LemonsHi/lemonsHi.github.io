{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/vexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","path":"fonts/SourceSansPro.ttf","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/qrious.js","path":"js/qrious.js","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/alipay.jpg","path":"css/images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/catalog.png","path":"css/images/catalog.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/error_icon.png","path":"css/images/error_icon.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/escheres.png","path":"css/images/escheres.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/icp.png","path":"css/images/icp.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/ga.png","path":"css/images/ga.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/logo.png","path":"css/images/logo.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/menu.png","path":"css/images/menu.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/top.png","path":"css/images/top.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/wechat.jpg","path":"css/images/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/plugins/gitment.css","path":"css/plugins/gitment.css","modified":1,"renderable":1},{"_id":"source/images/image.png","path":"images/image.png","modified":1,"renderable":0},{"_id":"source/images/js-event-bubbling.png","path":"images/js-event-bubbling.png","modified":1,"renderable":0},{"_id":"source/images/js-event-capturing.png","path":"images/js-event-capturing.png","modified":1,"renderable":0},{"_id":"source/images/react-event-1.awebp","path":"images/react-event-1.awebp","modified":1,"renderable":0},{"_id":"source/images/react-event-2.awebp","path":"images/react-event-2.awebp","modified":1,"renderable":0},{"_id":"source/images/react-event-3.awebp","path":"images/react-event-3.awebp","modified":1,"renderable":0},{"_id":"source/images/react-event-5.webp","path":"images/react-event-5.webp","modified":1,"renderable":0},{"_id":"source/images/react-event-6.webp","path":"images/react-event-6.webp","modified":1,"renderable":0},{"_id":"source/images/react-evnet-4.awebp","path":"images/react-evnet-4.awebp","modified":1,"renderable":0},{"_id":"source/images/react事件池.png","path":"images/react事件池.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/React-事件机制.md","hash":"3c83d086e468303721d94231b6c969e4072bb12a","modified":1711959814004},{"_id":"source/_posts/newpapername.md","hash":"aadcc54e7f5d5f7abccaf9137d2f29489524237f","modified":1711709463069},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1711711350787},{"_id":"source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1711708727915},{"_id":"source/images/react-event-1.awebp","hash":"4b7cfca802424f61bcc15bcd9e29f73529c0ca69","modified":1711947788879},{"_id":"source/images/js-event-bubbling.png","hash":"6d87c88238f43afad9c3b4bf73c204731f24c820","modified":1711943619634},{"_id":"source/images/react-event-2.awebp","hash":"8bab79f5ea3a30f64fdc40e6e12fd3b39feb8264","modified":1711947923102},{"_id":"source/images/react-event-5.webp","hash":"1236f857bb670b0ee8cbbc5e55da08eb51debd13","modified":1711959303693},{"_id":"source/images/react-event-6.webp","hash":"ad4c99873db582b8e5eae77e1b8d1e8110a489ed","modified":1711959493655},{"_id":"source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1711708727919},{"_id":"source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1711708727916},{"_id":"source/series/index.md","hash":"364b07ea1e0b28e792fc7bbddac0069c771dbefa","modified":1711708727918},{"_id":"source/images/react-evnet-4.awebp","hash":"a8e34f368ece617b3b802851d1131c03bb2d328c","modified":1711959076983},{"_id":"source/images/image.png","hash":"259f11eae1cd21f309c2ad8d47d28e301e6aa51f","modified":1711942349997},{"_id":"source/images/js-event-capturing.png","hash":"f1e091119fba785b29c970cb12320d0ef92b9525","modified":1711946727216},{"_id":"source/images/react-event-3.awebp","hash":"415f50f76d21e67fe765910a4af104871fb78f50","modified":1711948311610},{"_id":"themes/vexo/.gitignore","hash":"37fb9fd49e7f944716efd3284a6bf55adb6dd0c2","modified":1711708701951},{"_id":"themes/vexo/LICENSE","hash":"3e135cd69c0e02c0a49dd43d571f600223cc61d1","modified":1711708701952},{"_id":"themes/vexo/_config.yml","hash":"f07f5df9177afd6299ca134fadc457159cb545f4","modified":1711709622836},{"_id":"themes/vexo/README.md","hash":"76d30348cde696a75dd4f50b0747c5e8e3779046","modified":1711708701952},{"_id":"themes/vexo/package.json","hash":"44e46ed458ca4351db2a773bb4c09ac814b7b1e0","modified":1711708701969},{"_id":"themes/vexo/.travis.yml","hash":"cc482f06f4ea6962058f2548dcb814b954876e76","modified":1711708701952},{"_id":"themes/vexo/layout/archive.ejs","hash":"f2480a73048bcb8673d78283090634d0857b80fb","modified":1711708701964},{"_id":"themes/vexo/lint.sh","hash":"f580302e4aa9ccfb95a253851da6501d145613fe","modified":1711708701968},{"_id":"themes/vexo/layout/about.ejs","hash":"76ba7418788eb2bb9ba46844f4d750734847d0b4","modified":1711708701964},{"_id":"themes/vexo/layout/index.ejs","hash":"9f12f5928d68d4d68175b825e18f89f3b0dfdb69","modified":1711708701965},{"_id":"themes/vexo/layout/layout.ejs","hash":"a7b8f1debdca12d667ecd1bcc3d4bc6e13a23d7b","modified":1711708701965},{"_id":"themes/vexo/layout/project.ejs","hash":"a023b833a64006989c718c8d6125978a87fa2c3e","modified":1711708701967},{"_id":"themes/vexo/layout/series.ejs","hash":"32010111ef27d2eefec44aba5a865064659d613a","modified":1711708701967},{"_id":"themes/vexo/layout/tags.ejs","hash":"256413f3c6098eba42fce8f24319913e4b2512dc","modified":1711708701968},{"_id":"themes/vexo/_source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1711708701954},{"_id":"themes/vexo/_source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1711708701953},{"_id":"themes/vexo/_source/series/index.md","hash":"364b07ea1e0b28e792fc7bbddac0069c771dbefa","modified":1711708701954},{"_id":"themes/vexo/_source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1711708701955},{"_id":"themes/vexo/layout/_partial/head.ejs","hash":"cbd8c09e3349ed4facec92d5068c4ee777d52418","modified":1711708701957},{"_id":"themes/vexo/layout/_partial/catalog.ejs","hash":"0352ce39c28074dcfc3bd6416680195eeb384fd1","modified":1711708701956},{"_id":"themes/vexo/layout/page.ejs","hash":"a0de4e82f1f96c55ab402ffa92c3e609ec87a14b","modified":1711710213608},{"_id":"themes/vexo/layout/_partial/archive.ejs","hash":"9abbf14034d581569c0b6c992fe22035cb5306b3","modified":1711708701956},{"_id":"themes/vexo/layout/_partial/header.ejs","hash":"8a3a4d5895330176e18bd6500b86b494c9246e7c","modified":1711708701958},{"_id":"themes/vexo/layout/_partial/tag.ejs","hash":"5d2a2c3f8ca7000945ab426a0c6939421974b224","modified":1711708701961},{"_id":"themes/vexo/layout/_partial/pager.ejs","hash":"3a1b9680fbfa3baa76933c7c17216996381ad241","modified":1711708701959},{"_id":"themes/vexo/layout/_partial/top.ejs","hash":"f09dea486246a580213005b21d4b38810dd16fb3","modified":1711708701961},{"_id":"themes/vexo/layout/_partial/nav.ejs","hash":"3d8ddc1f6e135a240d40edd157cf37f5d0a12df6","modified":1711708701958},{"_id":"themes/vexo/layout/_partial/footer.ejs","hash":"ed5340673c2bef6c0ef0eab52a34d8c7967624be","modified":1711709341569},{"_id":"themes/vexo/layout/_third-party/google_analytics.ejs","hash":"d09107a4ee5753a2fbbdb16ddf79d23ff0618c19","modified":1711708701962},{"_id":"themes/vexo/layout/_third-party/mathjax.ejs","hash":"aa58f0cfe22e7151c1a0521bbfa5cbd76f6dcd9d","modified":1711708701963},{"_id":"themes/vexo/layout/_third-party/localsearch.ejs","hash":"fdf9e9f25b673c3f66694581cf5ebb578e5393b9","modified":1711708701963},{"_id":"themes/vexo/source/css/_config.styl","hash":"0c9c0e77d6b8813cb76494e8d757843aab9e117b","modified":1711708701970},{"_id":"themes/vexo/source/css/style.styl","hash":"9dcd5509187654c29d0d908016a052fd164d257c","modified":1711708701983},{"_id":"themes/vexo/source/js/local-search.js","hash":"2d4c35e67f6ae2234a220c2898534d5bcb5245a2","modified":1711708701987},{"_id":"themes/vexo/source/js/script.js","hash":"1e0a395deba4f5ae66a5758590e094d26d777421","modified":1711708701988},{"_id":"themes/vexo/layout/_partial/search/localsearch_view.ejs","hash":"79e5e1a159d18b9e05961a47a4607b14be447e50","modified":1711708701960},{"_id":"themes/vexo/source/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1711708701988},{"_id":"themes/vexo/source/css/_partial/archive.styl","hash":"e80ddf26f2af3523632afeabd57f81592537985a","modified":1711708701971},{"_id":"themes/vexo/layout/_partial/search/localsearch_button.ejs","hash":"3cb21e8d581ee998796f3f4bf9cd00abb9a67072","modified":1711708701960},{"_id":"themes/vexo/source/css/_partial/about.styl","hash":"1fc9572052194d94f86224a860e6b52435492e57","modified":1711708701971},{"_id":"themes/vexo/source/css/_partial/catalog.styl","hash":"e3fd04eb0ae723def29592a0063e0706046cb6f2","modified":1711708701972},{"_id":"themes/vexo/source/css/_partial/categories.styl","hash":"d78cf86064428693e2173b4f23535cf311d18091","modified":1711708701972},{"_id":"themes/vexo/source/css/_partial/header.styl","hash":"6154d83977e8e725c52786b14a4d9b3bc62b1061","modified":1711708701974},{"_id":"themes/vexo/source/css/_partial/footer.styl","hash":"d90207a2b25e7a7a12b94cfcd5dde070422783e7","modified":1711708701974},{"_id":"themes/vexo/source/css/_partial/nav.styl","hash":"e92c010c5cd460e75c67083df8cdd0bf4d25cde4","modified":1711708701975},{"_id":"themes/vexo/source/css/_partial/markdown.styl","hash":"2a1a99a0a8a9ffab1e64b7d7c9241ce8d5c84c39","modified":1711708701975},{"_id":"themes/vexo/source/css/_partial/pager.styl","hash":"888384c67429c7568aa38b5ebe5acae3cc4de367","modified":1711708701976},{"_id":"themes/vexo/source/css/_partial/project.styl","hash":"e9b6faadf4852bce3a4141cba0a102a7afb81e9f","modified":1711708701976},{"_id":"themes/vexo/source/css/_partial/tags.styl","hash":"5198a7f7c221341138ae5c65185e86b6e13e8e26","modified":1711708701977},{"_id":"themes/vexo/source/css/_partial/search.styl","hash":"4fa3d5c7efd1de510719157bd7a6ab3c9f24e9fd","modified":1711708701977},{"_id":"themes/vexo/source/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1711708701979},{"_id":"themes/vexo/source/css/images/error_icon.png","hash":"efec6e759508dd02e6fa8c4facd9a25a61aae055","modified":1711708701979},{"_id":"themes/vexo/source/css/images/logo.png","hash":"718c6e48956249121cf3cca1a22a99f8372a3f0d","modified":1711708701981},{"_id":"themes/vexo/source/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1711708701980},{"_id":"themes/vexo/source/css/images/alipay.jpg","hash":"c49822ea6f06f868c2404fb00a93f913c8fff7b5","modified":1711708701978},{"_id":"themes/vexo/source/css/images/icp.png","hash":"28a83ac96146b1e0513a6eb68a24a591cd59821c","modified":1711708701981},{"_id":"themes/vexo/source/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1711708701981},{"_id":"themes/vexo/source/css/images/ga.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1711708701980},{"_id":"themes/vexo/source/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1711708701982},{"_id":"themes/vexo/source/css/images/wechat.jpg","hash":"5bed6d3eb9f71b227b0ea0187c1a7ba8caf5ee64","modified":1711708701982},{"_id":"themes/vexo/source/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1711708701983},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1711708701985},{"_id":"themes/vexo/source/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1711708701987},{"_id":"source/images/react事件池.png","hash":"e6f4d4699d131b21441f7c025f678a35967b46bb","modified":1711958810753},{"_id":"public/series/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1711960529688},{"_id":"public/project/index.html","hash":"c43d75fc084ab3e413691accbbe5ad370e1019f0","modified":1711960529688},{"_id":"public/tags/index.html","hash":"34ce8c52937619063a5a37d7543972382de2bf65","modified":1711960529688},{"_id":"public/about/index.html","hash":"c435fa13a069170788b6ae469de48f0faaaae75c","modified":1711960529688},{"_id":"public/newpapername/index.html","hash":"dc28eccbfd49c48faab9e63d62a5cb58b7fb9059","modified":1711960529688},{"_id":"public/hello-world/index.html","hash":"4f5b12258520f183070c2c0671e9432cde0921c0","modified":1711960529688},{"_id":"public/archives/index.html","hash":"919ba86a32be26728e5ef6c7264641a9deb43904","modified":1711960529688},{"_id":"public/archives/2024/index.html","hash":"ce42769caa6e2b912f4ea560f53d62b3362888e4","modified":1711960529688},{"_id":"public/archives/2024/03/index.html","hash":"309cf8c38ad713f77d80eb885c9c8e2245060cb3","modified":1711960529688},{"_id":"public/archives/2024/04/index.html","hash":"077b8acb88944d0a7baee628c6d243e9879f9480","modified":1711960529688},{"_id":"public/index.html","hash":"c25327fd03e5638750629a831dd0835ab8696f36","modified":1711960529688},{"_id":"public/tags/React/index.html","hash":"be392ac75559577f4a74bebfaa65a2c9cf057aab","modified":1711960529688},{"_id":"public/React-事件机制/index.html","hash":"95e5aff43019cdf49b1c6399dcaf433b2b9fadbe","modified":1711960529688},{"_id":"public/css/images/alipay.jpg","hash":"c49822ea6f06f868c2404fb00a93f913c8fff7b5","modified":1711960529688},{"_id":"public/css/images/error_icon.png","hash":"efec6e759508dd02e6fa8c4facd9a25a61aae055","modified":1711960529688},{"_id":"public/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1711960529688},{"_id":"public/css/images/ga.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1711960529688},{"_id":"public/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1711960529688},{"_id":"public/css/images/icp.png","hash":"28a83ac96146b1e0513a6eb68a24a591cd59821c","modified":1711960529688},{"_id":"public/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1711960529688},{"_id":"public/css/images/logo.png","hash":"718c6e48956249121cf3cca1a22a99f8372a3f0d","modified":1711960529688},{"_id":"public/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1711960529688},{"_id":"public/css/images/wechat.jpg","hash":"5bed6d3eb9f71b227b0ea0187c1a7ba8caf5ee64","modified":1711960529688},{"_id":"public/images/react-event-1.awebp","hash":"4b7cfca802424f61bcc15bcd9e29f73529c0ca69","modified":1711960529688},{"_id":"public/images/js-event-bubbling.png","hash":"6d87c88238f43afad9c3b4bf73c204731f24c820","modified":1711960529688},{"_id":"public/images/react-event-2.awebp","hash":"8bab79f5ea3a30f64fdc40e6e12fd3b39feb8264","modified":1711960529688},{"_id":"public/images/react-event-5.webp","hash":"1236f857bb670b0ee8cbbc5e55da08eb51debd13","modified":1711960529688},{"_id":"public/images/react-evnet-4.awebp","hash":"a8e34f368ece617b3b802851d1131c03bb2d328c","modified":1711960529688},{"_id":"public/images/react-event-6.webp","hash":"ad4c99873db582b8e5eae77e1b8d1e8110a489ed","modified":1711960529688},{"_id":"public/js/local-search.js","hash":"2d4c35e67f6ae2234a220c2898534d5bcb5245a2","modified":1711960529688},{"_id":"public/js/script.js","hash":"1e0a395deba4f5ae66a5758590e094d26d777421","modified":1711960529688},{"_id":"public/css/style.css","hash":"46d24cb6f6d08acee68a39805d38bf5398be5d98","modified":1711960529688},{"_id":"public/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1711960529688},{"_id":"public/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1711960529688},{"_id":"public/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1711960529688},{"_id":"public/images/image.png","hash":"259f11eae1cd21f309c2ad8d47d28e301e6aa51f","modified":1711960529688},{"_id":"public/images/js-event-capturing.png","hash":"f1e091119fba785b29c970cb12320d0ef92b9525","modified":1711960529688},{"_id":"public/images/react-event-3.awebp","hash":"415f50f76d21e67fe765910a4af104871fb78f50","modified":1711960529688},{"_id":"public/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1711960529688},{"_id":"public/images/react事件池.png","hash":"e6f4d4699d131b21441f7c025f678a35967b46bb","modified":1711960529688}],"Category":[],"Data":[],"Page":[{"title":"Project","layout":"project","_content":"","source":"project/index.md","raw":"---\ntitle: Project\nlayout: project\n---\n","date":"2024-03-29T10:38:47.916Z","updated":"2024-03-29T10:38:47.916Z","path":"project/index.html","comments":1,"_id":"clugp3j2z0000gammfxae0sfa","content":"","excerpt":"","more":""},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\n---\n","date":"2024-03-29T10:38:47.919Z","updated":"2024-03-29T10:38:47.919Z","path":"tags/index.html","comments":1,"_id":"clugp3j350002gammdvz7f7ek","content":"","excerpt":"","more":""},{"title":"About","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: About\nlayout: about\n---","date":"2024-03-29T10:38:47.915Z","updated":"2024-03-29T10:38:47.915Z","path":"about/index.html","comments":1,"_id":"clugp3j390005gamm4menffhp","content":"","excerpt":"","more":""},{"title":"Series","layout":"series","_content":"","source":"series/index.md","raw":"---\ntitle: Series\nlayout: series\n---\n","date":"2024-03-29T10:38:47.918Z","updated":"2024-03-29T10:38:47.918Z","path":"series/index.html","comments":1,"_id":"clugp3j3b0007gamm0x0c9k97","content":"","excerpt":"","more":""}],"Post":[{"title":"React 事件机制（1）","date":"2024-04-01T03:29:21.000Z","_content":"\n## 1. 原生事件\n\n一个简单的例子\n\n```html\n<div onclick=\"alert('The handler!')\">\n  <ul>\n    <li>Coffee</li>\n    <li>Tea</li>\n    <li>Milk</li>\n  </ul>\n</div>\n```\n\n> 无论点击 Coffee、Tea 或 Milk 都会触发 div 上面绑定的 onclick 逻辑\n\n实际上点击的是 `<li>`，但为什么在 `<div>` 上的处理程序会运行？\n\n### 1.1 事件冒泡\n\n**当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。**\n\n在看一个例子\n\n```html\n<div onclick=\"alert('div-1')\">\n  div-1\n  <div onclick=\"alert('div-2')\">\n    div-2\n    <div onclick=\"alert('div-3')\">div-3</div>\n  </div>\n</div>\n```\n\n> 如果我们点击最内部 `<div>`，那么我们将看到 3 个 alert：div-3 → div-2 → div-1\n\n![](../images/js-event-bubbling.png)\n\n这个过程被称为“冒泡（bubbling）”，因为事件从内部元素“冒泡”到所有父级，**就像在水里的气泡一样。**\n\n### 1.2 事件捕获\n\nDOM 事件标准描述了事件传播的 3 个阶段：\n\n- 捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。\n- 目标阶段（Target phase）—— 事件到达目标元素。\n- 冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。\n\n![](../images/js-event-capturing.png)\n\n> 在点击 `<td>` 标签后，事件首先通过祖先链向下到达元素 **（捕获阶段）**，然后到达目标 **（目标阶段）**，最后上升 **（冒泡阶段）**，在途中调用处理程序。\n\n### 1.3 事件代理/事件委托\n\n> 简单理解就是将一个响应事件委托到另一个元素。\n\n当子节点被点击时，事件向上冒泡，父节点捕获到事件后，我们判断是否为所需的节点，然后进行处理。 **其优点在于减少内存消耗和动态绑定事件。**\n\n## 2. React 事件机制\n\nReact 自身实现了一套自己的事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等，虽然和原生的是两码事，但也是 **基于浏览器的事件机制下完成的。**\n\nReact 的所有事件并没有绑定到具体的 `DOM` 节点上而是绑定在了 `document` 上，然后由统一的事件处理程序来处理，同时也是基于浏览器的事件机制（冒泡），所有节点的事件都会在 `document` 上触发。\n\n### 2.1 事件解析\n\n```js\nclass Index extends React.Component {\n  handerClick = (value) => console.log(value)\n  render() {\n    return (\n      <div>\n        <button onClick={this.handerClick}> 按钮点击 </button>\n      </div>\n    )\n  }\n}\n```\n\n经过 babel 转换成 React.createElement 形式，如下：\n\n![](../images/react-event-1.awebp)\n\n> 事件通过 props 的形式传入 React.createElement 方法中\n\n最终得到的 fiber 的对象形式，如下：\n\n![](../images/react-event-2.awebp)\n\n> fiber 对象上的 memoizedProps 和 pendingProps 保存了相关事件。\n\n### 2.2 事件绑定\n\n一个简单的例子，如下：\n\n```js\nclass Index extends React.Component {\n  componentDidMount() {\n    console.log(this)\n  }\n  handerClick = (value) => console.log(value)\n  handerChange = (value) => console.log(value)\n  render() {\n    return (\n      <div style={{ marginTop: '50px' }}>\n        <button onClick={this.handerClick}> 按钮点击 </button>\n        <input placeholder=\"请输入内容\" onChange={this.handerChange} />\n      </div>\n    )\n  }\n}\n```\n\n从浏览器中看事件绑定\n\n![](../images/react-event-3.awebp)\n\n我们给 `<input>` 标签绑定的 `onChange` 事件，并没有直接绑定在 `<input>` 上，而是统一绑定在了 `document` 上，然后我们 `onChange` 被处理成很多事件监听器，比如 `blur`，`change`，`input`，`keydown`，`keyup` 等。\n\n**综上我们可以得出结论：**\n\n- 我们在 `jsx` 中绑定的事件，根本就没有注册到真实的 `DOM` 上。是绑定在 `document` 上统一管理的。\n- 真实的 `DOM` 上的 `click` 事件被单独处理，已经被 React 底层替换成空函数。\n- 我们在 React 绑定的事件,比如 `onChange`，在 `document` 上，可能有多个事件与之对应。\n- React 并不是一开始，把所有的事件都绑定在 `document` 上，而是采取了一种按需绑定，比如发现了 `onClick` 事件，再去绑定 `document click` 事件。\n\n### 2.3 执行顺序\n\nReact 事件和原生事件的执行顺序是如何的呢？\n\nDOM 事件标准描述了事件传播的 3 个阶段，如下：\n\n![](../images/js-event-capturing.png)\n\n- 捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。\n- 目标阶段（Target phase）—— 事件到达目标元素。\n- 冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。\n\n由于 React 合成事件的触发是基于浏览器的事件机制来实现的，通过冒泡机制冒泡到最顶层元素，然后再由 `dispatchEvent` 统一去处理。\n\n**综上我们可以得出结论：**\n\n- 优先处理 `DOM` 原生事件优先触发，后处理 React 事件，最后执行 `document` 上挂载的事件。\n- 原生事件阻止冒泡肯定会阻止合成事件的触发。\n- 合成事件的阻止冒泡不会影响原生事件。\n\n> React 自己做这么多的意义是什么？\n>\n> - 减少内存消耗，提升性能，不需要注册那么多的事件了，一种事件类型只在 document 上注册一次。\n> - 统一规范，解决 ie 事件兼容问题，简化事件逻辑。\n> - 对开发者友好。\n\n### 2.4 合成事件与原生事件区别\n\n#### 2.4.1 事件名称命名方式不同\n\n原生事件命名为纯小写，而 React 事件命名采用小驼峰式，如下所示：\n\n```js\n// 原生事件绑定方式\n;<button onclick=\"handleClick()\">Leo 按钮命名</button>\n\n// React 合成事件绑定方式\nconst button = <button onClick={handleClick}>Leo 按钮命名</button>\n```\n\n#### 2.4.2 事件处理函数写法不同\n\n原生事件中事件处理函数为字符串，在 React JSX 语法中，传入一个函数作为事件处理函数，如下所示：\n\n```js\n// 原生事件 事件处理函数写法\n;<button onclick=\"handleClick()\">Leo 按钮命名</button>\n\n// React 合成事件 事件处理函数写法\nconst button = <button onClick={handleClick}>Leo 按钮命名</button>\n```\n\n#### 2.4.3 阻止默认行为方式不同\n\n在原生事件中，可以通过返回 `false` 方式来阻止默认行为，但是在 React 中，需要显式使用 `preventDefault()` 方法来阻止，如下所示：\n\n```js\n// 原生事件阻止默认行为方式\n;<a\n  href=\"https://www.pingan8787.com\"\n  onclick=\"console.log('Leo 阻止原生事件~'); return false\"\n>\n  Leo 阻止原生事件\n</a>\n\n// React 事件阻止默认行为方式\nconst handleClick = (e) => {\n  e.preventDefault()\n  console.log('Leo 阻止原生事件~')\n}\nconst clickElement = (\n  <a href=\"https://www.pingan8787.com\" onClick={handleClick}>\n    Leo 阻止原生事件\n  </a>\n)\n```\n\n### 2.5 合成事件池\n\n合成事件对象池，是 React 事件系统提供的一种性能优化方式。不同类型的合成事件具有不同的对象池。\n\n- 当对象池未满时，React 创建新的事件对象，派发给组件。\n- 当对象池装满时，React 从池中复用事件对象，派发给组件。\n\n![](../images/react事件池.png)\n\n#### 2.5.1 事件池分析（React 16 版本）\n\n```js\nfunction handleChange(e) {\n  console.log('原始数据：', e.target)\n  setTimeout(() => {\n    console.log('定时任务 e.target：', e.target) // null\n    console.log('定时任务：e：', e)\n  }, 100)\n}\nfunction App() {\n  return (\n    <div className=\"App\">\n      <button onClick={handleChange}>测试事件池</button>\n    </div>\n  )\n}\n\nexport default App\n```\n\n可以看到输出：\n\n![](../images/react-event-5.webp)\n\n对于一次点击事件的处理函数，在正常的函数执行上下文中打印 `e.target` 就指向了 `DOM` 元素，但是在 `setTimeout` 中打印却是 `null`，如果这不是 React 事件系统，两次打印的应该是一样的，但是为什么两次打印不一样呢？\n\n在 React 采取了一个事件池的概念，每次我们用的事件源对象，在事件函数执行之后，可以通过 `releaseTopLevelCallbackBookKeeping` 等方法将事件源对象释放到事件池中，这样的好处每次我们不必再创建事件源对象，可以从事件池中取出一个事件源对象进行复用，在事件处理函数执行完毕后，会释放事件源到事件池中，清空属性，这就是 `setTimeout` 中打印为什么是 `null` 的原因了。\n\n在 React 16 及之前的版本，合成事件对象的事件处理函数全部被调用之后，所有属性都会被置为  `null`。这时，如果我们需要在事件处理函数运行之后获取事件对象的属性，可以使用 React 提供的 `e.persist()` 方法，保留所有属性：\n\n```js\n// 只修改 handleChange 方法，其他不变\nfunction handleChange(e) {\n  // 只增加 persist() 执行\n  e.persist()\n\n  console.log('原始数据：', e.target)\n  setTimeout(() => {\n    console.log('定时任务 e.target：', e.target) // null\n    console.log('定时任务：e：', e)\n  }, 100)\n}\n```\n\n结果如下：\n\n![](../images/react-event-6.webp)\n\n#### 2.5.2 事件池分析（React 17 版本）\n\n##### 绑定对象\n\n事件统一绑定 `container` 上（`ReactDOM.render(app, container)`），而不是 `document` 上，这样好处是有利于微前端的，微前端一个前端系统中可能有多个应用，如果继续采取全部绑定在 `document` 上，那么可能多应用下会出现问题。\n\n![](../images/react-evnet-4.awebp)\n\n##### 对齐原生浏览器事件\n\nReact 17 中终于支持了原生捕获事件的支持， 对齐了浏览器原生标准。同时 `onScroll` 事件不再进行事件冒泡。`onFocus` 和 `onBlur` 使用原生 `focusin，` `focusout` 合成。\n\n##### 取消事件池\n\n取消事件池 React 17 取消事件池复用，也就解决了上述在 `setTimeout` 打印，找不到 `e.target` 的问题。\n","source":"_posts/React-事件机制.md","raw":"---\ntitle: React 事件机制（1）\ndate: 2024-04-01 11:29:21\ntags: [React]\n---\n\n## 1. 原生事件\n\n一个简单的例子\n\n```html\n<div onclick=\"alert('The handler!')\">\n  <ul>\n    <li>Coffee</li>\n    <li>Tea</li>\n    <li>Milk</li>\n  </ul>\n</div>\n```\n\n> 无论点击 Coffee、Tea 或 Milk 都会触发 div 上面绑定的 onclick 逻辑\n\n实际上点击的是 `<li>`，但为什么在 `<div>` 上的处理程序会运行？\n\n### 1.1 事件冒泡\n\n**当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。**\n\n在看一个例子\n\n```html\n<div onclick=\"alert('div-1')\">\n  div-1\n  <div onclick=\"alert('div-2')\">\n    div-2\n    <div onclick=\"alert('div-3')\">div-3</div>\n  </div>\n</div>\n```\n\n> 如果我们点击最内部 `<div>`，那么我们将看到 3 个 alert：div-3 → div-2 → div-1\n\n![](../images/js-event-bubbling.png)\n\n这个过程被称为“冒泡（bubbling）”，因为事件从内部元素“冒泡”到所有父级，**就像在水里的气泡一样。**\n\n### 1.2 事件捕获\n\nDOM 事件标准描述了事件传播的 3 个阶段：\n\n- 捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。\n- 目标阶段（Target phase）—— 事件到达目标元素。\n- 冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。\n\n![](../images/js-event-capturing.png)\n\n> 在点击 `<td>` 标签后，事件首先通过祖先链向下到达元素 **（捕获阶段）**，然后到达目标 **（目标阶段）**，最后上升 **（冒泡阶段）**，在途中调用处理程序。\n\n### 1.3 事件代理/事件委托\n\n> 简单理解就是将一个响应事件委托到另一个元素。\n\n当子节点被点击时，事件向上冒泡，父节点捕获到事件后，我们判断是否为所需的节点，然后进行处理。 **其优点在于减少内存消耗和动态绑定事件。**\n\n## 2. React 事件机制\n\nReact 自身实现了一套自己的事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等，虽然和原生的是两码事，但也是 **基于浏览器的事件机制下完成的。**\n\nReact 的所有事件并没有绑定到具体的 `DOM` 节点上而是绑定在了 `document` 上，然后由统一的事件处理程序来处理，同时也是基于浏览器的事件机制（冒泡），所有节点的事件都会在 `document` 上触发。\n\n### 2.1 事件解析\n\n```js\nclass Index extends React.Component {\n  handerClick = (value) => console.log(value)\n  render() {\n    return (\n      <div>\n        <button onClick={this.handerClick}> 按钮点击 </button>\n      </div>\n    )\n  }\n}\n```\n\n经过 babel 转换成 React.createElement 形式，如下：\n\n![](../images/react-event-1.awebp)\n\n> 事件通过 props 的形式传入 React.createElement 方法中\n\n最终得到的 fiber 的对象形式，如下：\n\n![](../images/react-event-2.awebp)\n\n> fiber 对象上的 memoizedProps 和 pendingProps 保存了相关事件。\n\n### 2.2 事件绑定\n\n一个简单的例子，如下：\n\n```js\nclass Index extends React.Component {\n  componentDidMount() {\n    console.log(this)\n  }\n  handerClick = (value) => console.log(value)\n  handerChange = (value) => console.log(value)\n  render() {\n    return (\n      <div style={{ marginTop: '50px' }}>\n        <button onClick={this.handerClick}> 按钮点击 </button>\n        <input placeholder=\"请输入内容\" onChange={this.handerChange} />\n      </div>\n    )\n  }\n}\n```\n\n从浏览器中看事件绑定\n\n![](../images/react-event-3.awebp)\n\n我们给 `<input>` 标签绑定的 `onChange` 事件，并没有直接绑定在 `<input>` 上，而是统一绑定在了 `document` 上，然后我们 `onChange` 被处理成很多事件监听器，比如 `blur`，`change`，`input`，`keydown`，`keyup` 等。\n\n**综上我们可以得出结论：**\n\n- 我们在 `jsx` 中绑定的事件，根本就没有注册到真实的 `DOM` 上。是绑定在 `document` 上统一管理的。\n- 真实的 `DOM` 上的 `click` 事件被单独处理，已经被 React 底层替换成空函数。\n- 我们在 React 绑定的事件,比如 `onChange`，在 `document` 上，可能有多个事件与之对应。\n- React 并不是一开始，把所有的事件都绑定在 `document` 上，而是采取了一种按需绑定，比如发现了 `onClick` 事件，再去绑定 `document click` 事件。\n\n### 2.3 执行顺序\n\nReact 事件和原生事件的执行顺序是如何的呢？\n\nDOM 事件标准描述了事件传播的 3 个阶段，如下：\n\n![](../images/js-event-capturing.png)\n\n- 捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。\n- 目标阶段（Target phase）—— 事件到达目标元素。\n- 冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。\n\n由于 React 合成事件的触发是基于浏览器的事件机制来实现的，通过冒泡机制冒泡到最顶层元素，然后再由 `dispatchEvent` 统一去处理。\n\n**综上我们可以得出结论：**\n\n- 优先处理 `DOM` 原生事件优先触发，后处理 React 事件，最后执行 `document` 上挂载的事件。\n- 原生事件阻止冒泡肯定会阻止合成事件的触发。\n- 合成事件的阻止冒泡不会影响原生事件。\n\n> React 自己做这么多的意义是什么？\n>\n> - 减少内存消耗，提升性能，不需要注册那么多的事件了，一种事件类型只在 document 上注册一次。\n> - 统一规范，解决 ie 事件兼容问题，简化事件逻辑。\n> - 对开发者友好。\n\n### 2.4 合成事件与原生事件区别\n\n#### 2.4.1 事件名称命名方式不同\n\n原生事件命名为纯小写，而 React 事件命名采用小驼峰式，如下所示：\n\n```js\n// 原生事件绑定方式\n;<button onclick=\"handleClick()\">Leo 按钮命名</button>\n\n// React 合成事件绑定方式\nconst button = <button onClick={handleClick}>Leo 按钮命名</button>\n```\n\n#### 2.4.2 事件处理函数写法不同\n\n原生事件中事件处理函数为字符串，在 React JSX 语法中，传入一个函数作为事件处理函数，如下所示：\n\n```js\n// 原生事件 事件处理函数写法\n;<button onclick=\"handleClick()\">Leo 按钮命名</button>\n\n// React 合成事件 事件处理函数写法\nconst button = <button onClick={handleClick}>Leo 按钮命名</button>\n```\n\n#### 2.4.3 阻止默认行为方式不同\n\n在原生事件中，可以通过返回 `false` 方式来阻止默认行为，但是在 React 中，需要显式使用 `preventDefault()` 方法来阻止，如下所示：\n\n```js\n// 原生事件阻止默认行为方式\n;<a\n  href=\"https://www.pingan8787.com\"\n  onclick=\"console.log('Leo 阻止原生事件~'); return false\"\n>\n  Leo 阻止原生事件\n</a>\n\n// React 事件阻止默认行为方式\nconst handleClick = (e) => {\n  e.preventDefault()\n  console.log('Leo 阻止原生事件~')\n}\nconst clickElement = (\n  <a href=\"https://www.pingan8787.com\" onClick={handleClick}>\n    Leo 阻止原生事件\n  </a>\n)\n```\n\n### 2.5 合成事件池\n\n合成事件对象池，是 React 事件系统提供的一种性能优化方式。不同类型的合成事件具有不同的对象池。\n\n- 当对象池未满时，React 创建新的事件对象，派发给组件。\n- 当对象池装满时，React 从池中复用事件对象，派发给组件。\n\n![](../images/react事件池.png)\n\n#### 2.5.1 事件池分析（React 16 版本）\n\n```js\nfunction handleChange(e) {\n  console.log('原始数据：', e.target)\n  setTimeout(() => {\n    console.log('定时任务 e.target：', e.target) // null\n    console.log('定时任务：e：', e)\n  }, 100)\n}\nfunction App() {\n  return (\n    <div className=\"App\">\n      <button onClick={handleChange}>测试事件池</button>\n    </div>\n  )\n}\n\nexport default App\n```\n\n可以看到输出：\n\n![](../images/react-event-5.webp)\n\n对于一次点击事件的处理函数，在正常的函数执行上下文中打印 `e.target` 就指向了 `DOM` 元素，但是在 `setTimeout` 中打印却是 `null`，如果这不是 React 事件系统，两次打印的应该是一样的，但是为什么两次打印不一样呢？\n\n在 React 采取了一个事件池的概念，每次我们用的事件源对象，在事件函数执行之后，可以通过 `releaseTopLevelCallbackBookKeeping` 等方法将事件源对象释放到事件池中，这样的好处每次我们不必再创建事件源对象，可以从事件池中取出一个事件源对象进行复用，在事件处理函数执行完毕后，会释放事件源到事件池中，清空属性，这就是 `setTimeout` 中打印为什么是 `null` 的原因了。\n\n在 React 16 及之前的版本，合成事件对象的事件处理函数全部被调用之后，所有属性都会被置为  `null`。这时，如果我们需要在事件处理函数运行之后获取事件对象的属性，可以使用 React 提供的 `e.persist()` 方法，保留所有属性：\n\n```js\n// 只修改 handleChange 方法，其他不变\nfunction handleChange(e) {\n  // 只增加 persist() 执行\n  e.persist()\n\n  console.log('原始数据：', e.target)\n  setTimeout(() => {\n    console.log('定时任务 e.target：', e.target) // null\n    console.log('定时任务：e：', e)\n  }, 100)\n}\n```\n\n结果如下：\n\n![](../images/react-event-6.webp)\n\n#### 2.5.2 事件池分析（React 17 版本）\n\n##### 绑定对象\n\n事件统一绑定 `container` 上（`ReactDOM.render(app, container)`），而不是 `document` 上，这样好处是有利于微前端的，微前端一个前端系统中可能有多个应用，如果继续采取全部绑定在 `document` 上，那么可能多应用下会出现问题。\n\n![](../images/react-evnet-4.awebp)\n\n##### 对齐原生浏览器事件\n\nReact 17 中终于支持了原生捕获事件的支持， 对齐了浏览器原生标准。同时 `onScroll` 事件不再进行事件冒泡。`onFocus` 和 `onBlur` 使用原生 `focusin，` `focusout` 合成。\n\n##### 取消事件池\n\n取消事件池 React 17 取消事件池复用，也就解决了上述在 `setTimeout` 打印，找不到 `e.target` 的问题。\n","slug":"React-事件机制","published":1,"updated":"2024-04-01T08:23:34.004Z","comments":1,"layout":"post","photos":[],"_id":"clugp3j320001gamm6ecj3woc","content":"<h2 id=\"1-原生事件\"><a href=\"#1-原生事件\" class=\"headerlink\" title=\"1. 原生事件\"></a>1. 原生事件</h2><p>一个简单的例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;alert(&#x27;The handler!&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Coffee<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Tea<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Milk<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>无论点击 Coffee、Tea 或 Milk 都会触发 div 上面绑定的 onclick 逻辑</p>\n</blockquote>\n<p>实际上点击的是 <code>&lt;li&gt;</code>，但为什么在 <code>&lt;div&gt;</code> 上的处理程序会运行？</p>\n<h3 id=\"1-1-事件冒泡\"><a href=\"#1-1-事件冒泡\" class=\"headerlink\" title=\"1.1 事件冒泡\"></a>1.1 事件冒泡</h3><p><strong>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。</strong></p>\n<p>在看一个例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;alert(&#x27;div-1&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">  div-1</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;alert(&#x27;div-2&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">    div-2</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;alert(&#x27;div-3&#x27;)&quot;</span>&gt;</span>div-3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果我们点击最内部 <code>&lt;div&gt;</code>，那么我们将看到 3 个 alert：div-3 → div-2 → div-1</p>\n</blockquote>\n<p><img src=\"/../images/js-event-bubbling.png\"></p>\n<p>这个过程被称为“冒泡（bubbling）”，因为事件从内部元素“冒泡”到所有父级，<strong>就像在水里的气泡一样。</strong></p>\n<h3 id=\"1-2-事件捕获\"><a href=\"#1-2-事件捕获\" class=\"headerlink\" title=\"1.2 事件捕获\"></a>1.2 事件捕获</h3><p>DOM 事件标准描述了事件传播的 3 个阶段：</p>\n<ul>\n<li>捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。</li>\n<li>目标阶段（Target phase）—— 事件到达目标元素。</li>\n<li>冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。</li>\n</ul>\n<p><img src=\"/../images/js-event-capturing.png\"></p>\n<blockquote>\n<p>在点击 <code>&lt;td&gt;</code> 标签后，事件首先通过祖先链向下到达元素 <strong>（捕获阶段）</strong>，然后到达目标 <strong>（目标阶段）</strong>，最后上升 <strong>（冒泡阶段）</strong>，在途中调用处理程序。</p>\n</blockquote>\n<h3 id=\"1-3-事件代理-事件委托\"><a href=\"#1-3-事件代理-事件委托\" class=\"headerlink\" title=\"1.3 事件代理&#x2F;事件委托\"></a>1.3 事件代理&#x2F;事件委托</h3><blockquote>\n<p>简单理解就是将一个响应事件委托到另一个元素。</p>\n</blockquote>\n<p>当子节点被点击时，事件向上冒泡，父节点捕获到事件后，我们判断是否为所需的节点，然后进行处理。 <strong>其优点在于减少内存消耗和动态绑定事件。</strong></p>\n<h2 id=\"2-React-事件机制\"><a href=\"#2-React-事件机制\" class=\"headerlink\" title=\"2. React 事件机制\"></a>2. React 事件机制</h2><p>React 自身实现了一套自己的事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等，虽然和原生的是两码事，但也是 <strong>基于浏览器的事件机制下完成的。</strong></p>\n<p>React 的所有事件并没有绑定到具体的 <code>DOM</code> 节点上而是绑定在了 <code>document</code> 上，然后由统一的事件处理程序来处理，同时也是基于浏览器的事件机制（冒泡），所有节点的事件都会在 <code>document</code> 上触发。</p>\n<h3 id=\"2-1-事件解析\"><a href=\"#2-1-事件解析\" class=\"headerlink\" title=\"2.1 事件解析\"></a>2.1 事件解析</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Index</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\">  handerClick = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value)</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handerClick&#125;</span>&gt;</span> 按钮点击 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过 babel 转换成 React.createElement 形式，如下：</p>\n<p><img src=\"/../images/react-event-1.awebp\"></p>\n<blockquote>\n<p>事件通过 props 的形式传入 React.createElement 方法中</p>\n</blockquote>\n<p>最终得到的 fiber 的对象形式，如下：</p>\n<p><img src=\"/../images/react-event-2.awebp\"></p>\n<blockquote>\n<p>fiber 对象上的 memoizedProps 和 pendingProps 保存了相关事件。</p>\n</blockquote>\n<h3 id=\"2-2-事件绑定\"><a href=\"#2-2-事件绑定\" class=\"headerlink\" title=\"2.2 事件绑定\"></a>2.2 事件绑定</h3><p>一个简单的例子，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Index</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">componentDidMount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handerClick = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value)</span><br><span class=\"line\">  handerChange = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value)</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">marginTop:</span> &#x27;<span class=\"attr\">50px</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handerClick&#125;</span>&gt;</span> 按钮点击 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;请输入内容&quot;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.handerChange&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从浏览器中看事件绑定</p>\n<p><img src=\"/../images/react-event-3.awebp\"></p>\n<p>我们给 <code>&lt;input&gt;</code> 标签绑定的 <code>onChange</code> 事件，并没有直接绑定在 <code>&lt;input&gt;</code> 上，而是统一绑定在了 <code>document</code> 上，然后我们 <code>onChange</code> 被处理成很多事件监听器，比如 <code>blur</code>，<code>change</code>，<code>input</code>，<code>keydown</code>，<code>keyup</code> 等。</p>\n<p><strong>综上我们可以得出结论：</strong></p>\n<ul>\n<li>我们在 <code>jsx</code> 中绑定的事件，根本就没有注册到真实的 <code>DOM</code> 上。是绑定在 <code>document</code> 上统一管理的。</li>\n<li>真实的 <code>DOM</code> 上的 <code>click</code> 事件被单独处理，已经被 React 底层替换成空函数。</li>\n<li>我们在 React 绑定的事件,比如 <code>onChange</code>，在 <code>document</code> 上，可能有多个事件与之对应。</li>\n<li>React 并不是一开始，把所有的事件都绑定在 <code>document</code> 上，而是采取了一种按需绑定，比如发现了 <code>onClick</code> 事件，再去绑定 <code>document click</code> 事件。</li>\n</ul>\n<h3 id=\"2-3-执行顺序\"><a href=\"#2-3-执行顺序\" class=\"headerlink\" title=\"2.3 执行顺序\"></a>2.3 执行顺序</h3><p>React 事件和原生事件的执行顺序是如何的呢？</p>\n<p>DOM 事件标准描述了事件传播的 3 个阶段，如下：</p>\n<p><img src=\"/../images/js-event-capturing.png\"></p>\n<ul>\n<li>捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。</li>\n<li>目标阶段（Target phase）—— 事件到达目标元素。</li>\n<li>冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。</li>\n</ul>\n<p>由于 React 合成事件的触发是基于浏览器的事件机制来实现的，通过冒泡机制冒泡到最顶层元素，然后再由 <code>dispatchEvent</code> 统一去处理。</p>\n<p><strong>综上我们可以得出结论：</strong></p>\n<ul>\n<li>优先处理 <code>DOM</code> 原生事件优先触发，后处理 React 事件，最后执行 <code>document</code> 上挂载的事件。</li>\n<li>原生事件阻止冒泡肯定会阻止合成事件的触发。</li>\n<li>合成事件的阻止冒泡不会影响原生事件。</li>\n</ul>\n<blockquote>\n<p>React 自己做这么多的意义是什么？</p>\n<ul>\n<li>减少内存消耗，提升性能，不需要注册那么多的事件了，一种事件类型只在 document 上注册一次。</li>\n<li>统一规范，解决 ie 事件兼容问题，简化事件逻辑。</li>\n<li>对开发者友好。</li>\n</ul>\n</blockquote>\n<h3 id=\"2-4-合成事件与原生事件区别\"><a href=\"#2-4-合成事件与原生事件区别\" class=\"headerlink\" title=\"2.4 合成事件与原生事件区别\"></a>2.4 合成事件与原生事件区别</h3><h4 id=\"2-4-1-事件名称命名方式不同\"><a href=\"#2-4-1-事件名称命名方式不同\" class=\"headerlink\" title=\"2.4.1 事件名称命名方式不同\"></a>2.4.1 事件名称命名方式不同</h4><p>原生事件命名为纯小写，而 React 事件命名采用小驼峰式，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原生事件绑定方式</span></span><br><span class=\"line\">;<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;handleClick()&quot;</span>&gt;</span>Leo 按钮命名<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// React 合成事件绑定方式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> button = <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleClick&#125;</span>&gt;</span>Leo 按钮命名<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-2-事件处理函数写法不同\"><a href=\"#2-4-2-事件处理函数写法不同\" class=\"headerlink\" title=\"2.4.2 事件处理函数写法不同\"></a>2.4.2 事件处理函数写法不同</h4><p>原生事件中事件处理函数为字符串，在 React JSX 语法中，传入一个函数作为事件处理函数，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原生事件 事件处理函数写法</span></span><br><span class=\"line\">;<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;handleClick()&quot;</span>&gt;</span>Leo 按钮命名<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// React 合成事件 事件处理函数写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> button = <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleClick&#125;</span>&gt;</span>Leo 按钮命名<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-3-阻止默认行为方式不同\"><a href=\"#2-4-3-阻止默认行为方式不同\" class=\"headerlink\" title=\"2.4.3 阻止默认行为方式不同\"></a>2.4.3 阻止默认行为方式不同</h4><p>在原生事件中，可以通过返回 <code>false</code> 方式来阻止默认行为，但是在 React 中，需要显式使用 <code>preventDefault()</code> 方法来阻止，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原生事件阻止默认行为方式</span></span><br><span class=\"line\">;<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">  <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://www.pingan8787.com&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">  <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;console.log(&#x27;Leo 阻止原生事件~&#x27;); return false&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  Leo 阻止原生事件</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// React 事件阻止默认行为方式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleClick</span> = (<span class=\"params\">e</span>) =&gt; &#123;</span><br><span class=\"line\">  e.<span class=\"title function_\">preventDefault</span>()</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Leo 阻止原生事件~&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> clickElement = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://www.pingan8787.com&quot;</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    Leo 阻止原生事件</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-合成事件池\"><a href=\"#2-5-合成事件池\" class=\"headerlink\" title=\"2.5 合成事件池\"></a>2.5 合成事件池</h3><p>合成事件对象池，是 React 事件系统提供的一种性能优化方式。不同类型的合成事件具有不同的对象池。</p>\n<ul>\n<li>当对象池未满时，React 创建新的事件对象，派发给组件。</li>\n<li>当对象池装满时，React 从池中复用事件对象，派发给组件。</li>\n</ul>\n<p><img src=\"/../images/react%E4%BA%8B%E4%BB%B6%E6%B1%A0.png\"></p>\n<h4 id=\"2-5-1-事件池分析（React-16-版本）\"><a href=\"#2-5-1-事件池分析（React-16-版本）\" class=\"headerlink\" title=\"2.5.1 事件池分析（React 16 版本）\"></a>2.5.1 事件池分析（React 16 版本）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleChange</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;原始数据：&#x27;</span>, e.<span class=\"property\">target</span>)</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;定时任务 e.target：&#x27;</span>, e.<span class=\"property\">target</span>) <span class=\"comment\">// null</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;定时任务：e：&#x27;</span>, e)</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;App&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleChange&#125;</span>&gt;</span>测试事件池<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到输出：</p>\n<p><img src=\"/../images/react-event-5.webp\"></p>\n<p>对于一次点击事件的处理函数，在正常的函数执行上下文中打印 <code>e.target</code> 就指向了 <code>DOM</code> 元素，但是在 <code>setTimeout</code> 中打印却是 <code>null</code>，如果这不是 React 事件系统，两次打印的应该是一样的，但是为什么两次打印不一样呢？</p>\n<p>在 React 采取了一个事件池的概念，每次我们用的事件源对象，在事件函数执行之后，可以通过 <code>releaseTopLevelCallbackBookKeeping</code> 等方法将事件源对象释放到事件池中，这样的好处每次我们不必再创建事件源对象，可以从事件池中取出一个事件源对象进行复用，在事件处理函数执行完毕后，会释放事件源到事件池中，清空属性，这就是 <code>setTimeout</code> 中打印为什么是 <code>null</code> 的原因了。</p>\n<p>在 React 16 及之前的版本，合成事件对象的事件处理函数全部被调用之后，所有属性都会被置为  <code>null</code>。这时，如果我们需要在事件处理函数运行之后获取事件对象的属性，可以使用 React 提供的 <code>e.persist()</code> 方法，保留所有属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 只修改 handleChange 方法，其他不变</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleChange</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 只增加 persist() 执行</span></span><br><span class=\"line\">  e.<span class=\"title function_\">persist</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;原始数据：&#x27;</span>, e.<span class=\"property\">target</span>)</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;定时任务 e.target：&#x27;</span>, e.<span class=\"property\">target</span>) <span class=\"comment\">// null</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;定时任务：e：&#x27;</span>, e)</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<p><img src=\"/../images/react-event-6.webp\"></p>\n<h4 id=\"2-5-2-事件池分析（React-17-版本）\"><a href=\"#2-5-2-事件池分析（React-17-版本）\" class=\"headerlink\" title=\"2.5.2 事件池分析（React 17 版本）\"></a>2.5.2 事件池分析（React 17 版本）</h4><h5 id=\"绑定对象\"><a href=\"#绑定对象\" class=\"headerlink\" title=\"绑定对象\"></a>绑定对象</h5><p>事件统一绑定 <code>container</code> 上（<code>ReactDOM.render(app, container)</code>），而不是 <code>document</code> 上，这样好处是有利于微前端的，微前端一个前端系统中可能有多个应用，如果继续采取全部绑定在 <code>document</code> 上，那么可能多应用下会出现问题。</p>\n<p><img src=\"/../images/react-evnet-4.awebp\"></p>\n<h5 id=\"对齐原生浏览器事件\"><a href=\"#对齐原生浏览器事件\" class=\"headerlink\" title=\"对齐原生浏览器事件\"></a>对齐原生浏览器事件</h5><p>React 17 中终于支持了原生捕获事件的支持， 对齐了浏览器原生标准。同时 <code>onScroll</code> 事件不再进行事件冒泡。<code>onFocus</code> 和 <code>onBlur</code> 使用原生 <code>focusin，</code> <code>focusout</code> 合成。</p>\n<h5 id=\"取消事件池\"><a href=\"#取消事件池\" class=\"headerlink\" title=\"取消事件池\"></a>取消事件池</h5><p>取消事件池 React 17 取消事件池复用，也就解决了上述在 <code>setTimeout</code> 打印，找不到 <code>e.target</code> 的问题。</p>\n","excerpt":"","more":"<h2 id=\"1-原生事件\"><a href=\"#1-原生事件\" class=\"headerlink\" title=\"1. 原生事件\"></a>1. 原生事件</h2><p>一个简单的例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;alert(&#x27;The handler!&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Coffee<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Tea<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Milk<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>无论点击 Coffee、Tea 或 Milk 都会触发 div 上面绑定的 onclick 逻辑</p>\n</blockquote>\n<p>实际上点击的是 <code>&lt;li&gt;</code>，但为什么在 <code>&lt;div&gt;</code> 上的处理程序会运行？</p>\n<h3 id=\"1-1-事件冒泡\"><a href=\"#1-1-事件冒泡\" class=\"headerlink\" title=\"1.1 事件冒泡\"></a>1.1 事件冒泡</h3><p><strong>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。</strong></p>\n<p>在看一个例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;alert(&#x27;div-1&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">  div-1</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;alert(&#x27;div-2&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">    div-2</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;alert(&#x27;div-3&#x27;)&quot;</span>&gt;</span>div-3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果我们点击最内部 <code>&lt;div&gt;</code>，那么我们将看到 3 个 alert：div-3 → div-2 → div-1</p>\n</blockquote>\n<p><img src=\"/../images/js-event-bubbling.png\"></p>\n<p>这个过程被称为“冒泡（bubbling）”，因为事件从内部元素“冒泡”到所有父级，<strong>就像在水里的气泡一样。</strong></p>\n<h3 id=\"1-2-事件捕获\"><a href=\"#1-2-事件捕获\" class=\"headerlink\" title=\"1.2 事件捕获\"></a>1.2 事件捕获</h3><p>DOM 事件标准描述了事件传播的 3 个阶段：</p>\n<ul>\n<li>捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。</li>\n<li>目标阶段（Target phase）—— 事件到达目标元素。</li>\n<li>冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。</li>\n</ul>\n<p><img src=\"/../images/js-event-capturing.png\"></p>\n<blockquote>\n<p>在点击 <code>&lt;td&gt;</code> 标签后，事件首先通过祖先链向下到达元素 <strong>（捕获阶段）</strong>，然后到达目标 <strong>（目标阶段）</strong>，最后上升 <strong>（冒泡阶段）</strong>，在途中调用处理程序。</p>\n</blockquote>\n<h3 id=\"1-3-事件代理-事件委托\"><a href=\"#1-3-事件代理-事件委托\" class=\"headerlink\" title=\"1.3 事件代理&#x2F;事件委托\"></a>1.3 事件代理&#x2F;事件委托</h3><blockquote>\n<p>简单理解就是将一个响应事件委托到另一个元素。</p>\n</blockquote>\n<p>当子节点被点击时，事件向上冒泡，父节点捕获到事件后，我们判断是否为所需的节点，然后进行处理。 <strong>其优点在于减少内存消耗和动态绑定事件。</strong></p>\n<h2 id=\"2-React-事件机制\"><a href=\"#2-React-事件机制\" class=\"headerlink\" title=\"2. React 事件机制\"></a>2. React 事件机制</h2><p>React 自身实现了一套自己的事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等，虽然和原生的是两码事，但也是 <strong>基于浏览器的事件机制下完成的。</strong></p>\n<p>React 的所有事件并没有绑定到具体的 <code>DOM</code> 节点上而是绑定在了 <code>document</code> 上，然后由统一的事件处理程序来处理，同时也是基于浏览器的事件机制（冒泡），所有节点的事件都会在 <code>document</code> 上触发。</p>\n<h3 id=\"2-1-事件解析\"><a href=\"#2-1-事件解析\" class=\"headerlink\" title=\"2.1 事件解析\"></a>2.1 事件解析</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Index</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\">  handerClick = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value)</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handerClick&#125;</span>&gt;</span> 按钮点击 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过 babel 转换成 React.createElement 形式，如下：</p>\n<p><img src=\"/../images/react-event-1.awebp\"></p>\n<blockquote>\n<p>事件通过 props 的形式传入 React.createElement 方法中</p>\n</blockquote>\n<p>最终得到的 fiber 的对象形式，如下：</p>\n<p><img src=\"/../images/react-event-2.awebp\"></p>\n<blockquote>\n<p>fiber 对象上的 memoizedProps 和 pendingProps 保存了相关事件。</p>\n</blockquote>\n<h3 id=\"2-2-事件绑定\"><a href=\"#2-2-事件绑定\" class=\"headerlink\" title=\"2.2 事件绑定\"></a>2.2 事件绑定</h3><p>一个简单的例子，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Index</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">componentDidMount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handerClick = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value)</span><br><span class=\"line\">  handerChange = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value)</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">marginTop:</span> &#x27;<span class=\"attr\">50px</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handerClick&#125;</span>&gt;</span> 按钮点击 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;请输入内容&quot;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.handerChange&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从浏览器中看事件绑定</p>\n<p><img src=\"/../images/react-event-3.awebp\"></p>\n<p>我们给 <code>&lt;input&gt;</code> 标签绑定的 <code>onChange</code> 事件，并没有直接绑定在 <code>&lt;input&gt;</code> 上，而是统一绑定在了 <code>document</code> 上，然后我们 <code>onChange</code> 被处理成很多事件监听器，比如 <code>blur</code>，<code>change</code>，<code>input</code>，<code>keydown</code>，<code>keyup</code> 等。</p>\n<p><strong>综上我们可以得出结论：</strong></p>\n<ul>\n<li>我们在 <code>jsx</code> 中绑定的事件，根本就没有注册到真实的 <code>DOM</code> 上。是绑定在 <code>document</code> 上统一管理的。</li>\n<li>真实的 <code>DOM</code> 上的 <code>click</code> 事件被单独处理，已经被 React 底层替换成空函数。</li>\n<li>我们在 React 绑定的事件,比如 <code>onChange</code>，在 <code>document</code> 上，可能有多个事件与之对应。</li>\n<li>React 并不是一开始，把所有的事件都绑定在 <code>document</code> 上，而是采取了一种按需绑定，比如发现了 <code>onClick</code> 事件，再去绑定 <code>document click</code> 事件。</li>\n</ul>\n<h3 id=\"2-3-执行顺序\"><a href=\"#2-3-执行顺序\" class=\"headerlink\" title=\"2.3 执行顺序\"></a>2.3 执行顺序</h3><p>React 事件和原生事件的执行顺序是如何的呢？</p>\n<p>DOM 事件标准描述了事件传播的 3 个阶段，如下：</p>\n<p><img src=\"/../images/js-event-capturing.png\"></p>\n<ul>\n<li>捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。</li>\n<li>目标阶段（Target phase）—— 事件到达目标元素。</li>\n<li>冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。</li>\n</ul>\n<p>由于 React 合成事件的触发是基于浏览器的事件机制来实现的，通过冒泡机制冒泡到最顶层元素，然后再由 <code>dispatchEvent</code> 统一去处理。</p>\n<p><strong>综上我们可以得出结论：</strong></p>\n<ul>\n<li>优先处理 <code>DOM</code> 原生事件优先触发，后处理 React 事件，最后执行 <code>document</code> 上挂载的事件。</li>\n<li>原生事件阻止冒泡肯定会阻止合成事件的触发。</li>\n<li>合成事件的阻止冒泡不会影响原生事件。</li>\n</ul>\n<blockquote>\n<p>React 自己做这么多的意义是什么？</p>\n<ul>\n<li>减少内存消耗，提升性能，不需要注册那么多的事件了，一种事件类型只在 document 上注册一次。</li>\n<li>统一规范，解决 ie 事件兼容问题，简化事件逻辑。</li>\n<li>对开发者友好。</li>\n</ul>\n</blockquote>\n<h3 id=\"2-4-合成事件与原生事件区别\"><a href=\"#2-4-合成事件与原生事件区别\" class=\"headerlink\" title=\"2.4 合成事件与原生事件区别\"></a>2.4 合成事件与原生事件区别</h3><h4 id=\"2-4-1-事件名称命名方式不同\"><a href=\"#2-4-1-事件名称命名方式不同\" class=\"headerlink\" title=\"2.4.1 事件名称命名方式不同\"></a>2.4.1 事件名称命名方式不同</h4><p>原生事件命名为纯小写，而 React 事件命名采用小驼峰式，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原生事件绑定方式</span></span><br><span class=\"line\">;<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;handleClick()&quot;</span>&gt;</span>Leo 按钮命名<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// React 合成事件绑定方式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> button = <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleClick&#125;</span>&gt;</span>Leo 按钮命名<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-2-事件处理函数写法不同\"><a href=\"#2-4-2-事件处理函数写法不同\" class=\"headerlink\" title=\"2.4.2 事件处理函数写法不同\"></a>2.4.2 事件处理函数写法不同</h4><p>原生事件中事件处理函数为字符串，在 React JSX 语法中，传入一个函数作为事件处理函数，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原生事件 事件处理函数写法</span></span><br><span class=\"line\">;<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;handleClick()&quot;</span>&gt;</span>Leo 按钮命名<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// React 合成事件 事件处理函数写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> button = <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleClick&#125;</span>&gt;</span>Leo 按钮命名<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-3-阻止默认行为方式不同\"><a href=\"#2-4-3-阻止默认行为方式不同\" class=\"headerlink\" title=\"2.4.3 阻止默认行为方式不同\"></a>2.4.3 阻止默认行为方式不同</h4><p>在原生事件中，可以通过返回 <code>false</code> 方式来阻止默认行为，但是在 React 中，需要显式使用 <code>preventDefault()</code> 方法来阻止，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原生事件阻止默认行为方式</span></span><br><span class=\"line\">;<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">  <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://www.pingan8787.com&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">  <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;console.log(&#x27;Leo 阻止原生事件~&#x27;); return false&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  Leo 阻止原生事件</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// React 事件阻止默认行为方式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleClick</span> = (<span class=\"params\">e</span>) =&gt; &#123;</span><br><span class=\"line\">  e.<span class=\"title function_\">preventDefault</span>()</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Leo 阻止原生事件~&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> clickElement = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://www.pingan8787.com&quot;</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    Leo 阻止原生事件</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-合成事件池\"><a href=\"#2-5-合成事件池\" class=\"headerlink\" title=\"2.5 合成事件池\"></a>2.5 合成事件池</h3><p>合成事件对象池，是 React 事件系统提供的一种性能优化方式。不同类型的合成事件具有不同的对象池。</p>\n<ul>\n<li>当对象池未满时，React 创建新的事件对象，派发给组件。</li>\n<li>当对象池装满时，React 从池中复用事件对象，派发给组件。</li>\n</ul>\n<p><img src=\"/../images/react%E4%BA%8B%E4%BB%B6%E6%B1%A0.png\"></p>\n<h4 id=\"2-5-1-事件池分析（React-16-版本）\"><a href=\"#2-5-1-事件池分析（React-16-版本）\" class=\"headerlink\" title=\"2.5.1 事件池分析（React 16 版本）\"></a>2.5.1 事件池分析（React 16 版本）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleChange</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;原始数据：&#x27;</span>, e.<span class=\"property\">target</span>)</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;定时任务 e.target：&#x27;</span>, e.<span class=\"property\">target</span>) <span class=\"comment\">// null</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;定时任务：e：&#x27;</span>, e)</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;App&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleChange&#125;</span>&gt;</span>测试事件池<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到输出：</p>\n<p><img src=\"/../images/react-event-5.webp\"></p>\n<p>对于一次点击事件的处理函数，在正常的函数执行上下文中打印 <code>e.target</code> 就指向了 <code>DOM</code> 元素，但是在 <code>setTimeout</code> 中打印却是 <code>null</code>，如果这不是 React 事件系统，两次打印的应该是一样的，但是为什么两次打印不一样呢？</p>\n<p>在 React 采取了一个事件池的概念，每次我们用的事件源对象，在事件函数执行之后，可以通过 <code>releaseTopLevelCallbackBookKeeping</code> 等方法将事件源对象释放到事件池中，这样的好处每次我们不必再创建事件源对象，可以从事件池中取出一个事件源对象进行复用，在事件处理函数执行完毕后，会释放事件源到事件池中，清空属性，这就是 <code>setTimeout</code> 中打印为什么是 <code>null</code> 的原因了。</p>\n<p>在 React 16 及之前的版本，合成事件对象的事件处理函数全部被调用之后，所有属性都会被置为  <code>null</code>。这时，如果我们需要在事件处理函数运行之后获取事件对象的属性，可以使用 React 提供的 <code>e.persist()</code> 方法，保留所有属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 只修改 handleChange 方法，其他不变</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleChange</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 只增加 persist() 执行</span></span><br><span class=\"line\">  e.<span class=\"title function_\">persist</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;原始数据：&#x27;</span>, e.<span class=\"property\">target</span>)</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;定时任务 e.target：&#x27;</span>, e.<span class=\"property\">target</span>) <span class=\"comment\">// null</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;定时任务：e：&#x27;</span>, e)</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<p><img src=\"/../images/react-event-6.webp\"></p>\n<h4 id=\"2-5-2-事件池分析（React-17-版本）\"><a href=\"#2-5-2-事件池分析（React-17-版本）\" class=\"headerlink\" title=\"2.5.2 事件池分析（React 17 版本）\"></a>2.5.2 事件池分析（React 17 版本）</h4><h5 id=\"绑定对象\"><a href=\"#绑定对象\" class=\"headerlink\" title=\"绑定对象\"></a>绑定对象</h5><p>事件统一绑定 <code>container</code> 上（<code>ReactDOM.render(app, container)</code>），而不是 <code>document</code> 上，这样好处是有利于微前端的，微前端一个前端系统中可能有多个应用，如果继续采取全部绑定在 <code>document</code> 上，那么可能多应用下会出现问题。</p>\n<p><img src=\"/../images/react-evnet-4.awebp\"></p>\n<h5 id=\"对齐原生浏览器事件\"><a href=\"#对齐原生浏览器事件\" class=\"headerlink\" title=\"对齐原生浏览器事件\"></a>对齐原生浏览器事件</h5><p>React 17 中终于支持了原生捕获事件的支持， 对齐了浏览器原生标准。同时 <code>onScroll</code> 事件不再进行事件冒泡。<code>onFocus</code> 和 <code>onBlur</code> 使用原生 <code>focusin，</code> <code>focusout</code> 合成。</p>\n<h5 id=\"取消事件池\"><a href=\"#取消事件池\" class=\"headerlink\" title=\"取消事件池\"></a>取消事件池</h5><p>取消事件池 React 17 取消事件池复用，也就解决了上述在 <code>setTimeout</code> 打印，找不到 <code>e.target</code> 的问题。</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2024-03-29T07:59:31.372Z","updated":"2024-03-29T11:22:30.787Z","comments":1,"layout":"post","photos":[],"_id":"clugp3j360003gamm8sw3gvp8","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"newpapername","date":"2024-03-29T10:19:22.000Z","_content":"","source":"_posts/newpapername.md","raw":"---\ntitle: newpapername\ndate: 2024-03-29 18:19:22\ntags: React\n---\n","slug":"newpapername","published":1,"updated":"2024-03-29T10:51:03.069Z","comments":1,"layout":"post","photos":[],"_id":"clugp3j3a0006gamm2di8cn8o","content":"","excerpt":"","more":""}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clugp3j320001gamm6ecj3woc","tag_id":"clugp3j380004gammepoe4z3r","_id":"clugp3j3d0009gammhn844a87"},{"post_id":"clugp3j3a0006gamm2di8cn8o","tag_id":"clugp3j380004gammepoe4z3r","_id":"clugp3j3d000agamm7ara6g17"}],"Tag":[{"name":"React","_id":"clugp3j380004gammepoe4z3r"}]}}