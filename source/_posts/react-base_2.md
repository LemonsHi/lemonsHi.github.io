---
title: React-base（2）
date: 2024-04-16 15:36:35
tags: React
---

## 1. workLoop

![](../images/react-base-1.png)

### 1.1 任务调度

`scheduler` 任务调度是 `react` 应用得以运行的保证，它需要循环调用，并控制所有任务（`task`）的调度

### 1.2 fiber 树构造循环

控制 fiber 树的构造，整个过程是一个深度优先遍历

> **深度优先遍历（Depth-First-Search，DFS）**：是一种用于遍历或搜索树或图的算法

## 2. 区别与联系

### 2.1 区别

1. 任务调度

   - 任务调度循环是以二叉堆为数据结构，循环执行堆的顶点，直到堆被清空
   - 任务调度循环的逻辑非常独立，它调度的是每一个任务（`task`），而不关心这个任务具体是干什么的（甚至可以将 `Scheduler` 包脱离 `react` 使用），具体任务其实就是执行回调函数 `performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`

2. fiber 树构造循环

   - `fiber` 构造循环是以树为数据结构，从上至下执行**深度优先遍历**
   - `fiber` 构造循环的逻辑偏向具体实现，它只是任务（`task`）的一部分，如 `performSyncWorkOnRoot` 包括：`fiber` 树的构造，`DOM` 渲染，调度检测），只负责 `fiber` 树的构造

### 2.2 联系

`fiber` 构造循环是任务调度循环中的任务（`task`）的一部分。它们是从属关系，每个任务都会重新构造一个 `fiber` 树

## 3. 核心逻辑

react 运行的核心逻辑，即将**输入转换为输出**的核心步骤，实际上就是围绕这两大工作循环进行展开

可以将 `react` 运行的主干逻辑进行概括：

1. **输入**：将每一次更新，如：新增，删除，修改节点之后，视为一次更新需求（目的是要更新 DOM 节点）
2. **注册调度任务**：`react-reconciler` 收到更新需求之后，并不会立即构造 `fiber` 树，而是去调度中心 `scheduler` 注册一个新任务 `task`，即把更新需求转换成一个 `task`
3. **执行调度任务（输出）**：调度中心 `scheduler` 通过任务调度循环来执行 `task`（`task` 的执行过程又回到了 `react-reconciler` 包中）
   - `fiber` 构造循环是 `task` 的实现环节之一，循环完成之后会构造出最新的 `fiber` 树
   - `commitRoot` 是 `task` 的实现环节之二，把最新的 `fiber` `树最终渲染到页面上，task` 完成

> 主干逻辑就是输入到输出这一条链路，为了更好的性能，如：批量更新，可中断渲染等功能，react 在输入到输出的链路上做了很多优化策略，比如：本文讲述的任务调度循环和 fiber 构造循环相互配合就可以实现可中断渲染
